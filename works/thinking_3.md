1、进程0 `fork` 进程1之前，为什么先调用`move_to_user_mode()`？用的是什么方法？解释其中的道理。
> 

2、为什么`static inline _syscall0(type,name)`中加上关键字`inline`？

3、`copy_process`函数的参数最后五项是：`long eip,long cs,long eflags,long esp,long ss`。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。

4、打开保护模式、分页后，线性地址到物理地址是如何转换的？

5、分析`get_free_page()`函数的代码，叙述在主内存中获取一个空闲页的技术路线。

6、分析`copy_page_tables()`函数的代码，叙述父进程如何为子进程复制页表。

7、进程0创建进程1时，为进程1建立了`task_struct`及内核栈，第一个页表，分别位于物理内存16MB顶端倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。

8、根据代码详细分析，进程0如何根据调度第一次切换到进程1的。

9、`switch_to(n)`代码中的`"ljmp %0\n\t"` 很奇怪，按理说`jmp`指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了`"m" (*&__tmp.a)`，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。

10、进程0开始创建进程1，调用`fork()`，跟踪代码时我们发现，`fork`代码执行了两次，第一次，执行`fork`代码后，跳过`init()`直接执行了`for(;;) pause()`，第二次执行`fork`代码后，执行了`init()`。奇怪的是，我们在代码中并没有看到向转向`fork`的`goto`语句，也没有看到循环语句，是什么原因导致`fork`反复执行？请说明理由（可以图示），并给出代码证据。

11、详细分析进程调度的全过程。考虑所有可能（`signal`、`alarm` 除外）